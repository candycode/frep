/*vec4 ComputeColor( vec3 P, vec3 n )
{
	vec3 normal, lightDir, viewVector, halfVector;
	vec4 diffuse, ambient, globalAmbient, specular = vec4(0.0);
	float NdotL,NdotHV;
	
	// first transform the normal into eye space and normalize the result 
	normal = normalize( n );
	
	// now normalize the light's direction. Note that according to the
	//OpenGL specification, the light is stored in eye space. Also since 
	//we're talking about a directional light, the position field is actually 
	//direction 
	//lightDir = normalize(vec3(gl_LightSource[0].position));
	
	// compute the cos of the angle between the normal and lights direction. 
	//The light is directional so the direction is constant for every vertex.
	//Since these two are normalized the cosine is the dot product. We also 
	//need to clamp the result to the [0,1] range. 
	
	NdotL = max(dot(normal, lightDir), 0.0);
	
	// Compute the diffuse, ambient and globalAmbient terms
	diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse;
	ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient;
	globalAmbient = gl_LightModel.ambient * gl_FrontMaterial.ambient;
	
	// compute the specular term if NdotL is  larger than zero
	if (NdotL > 0.0) {

		NdotHV = max(dot(normal, normalize(gl_LightSource[0].halfVector.xyz)),0.0);
		specular = gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV,gl_FrontMaterial.shininess);
	}
	
	return globalAmbient + NdotL * diffuse + ambient + specular;

}*/

vec4 ComputeColor( vec3 P, vec3 n )
{
  const vec4 color = vec4( 0.8, 0.3, 0.3, 1.0 );
   const float kd = 1.0;
  float ka = 0.01;
  float ks = 1.;
  float sh = 100.;
  const vec3 refcolor = vec3( 1, 1, 1 );
  const vec3 lightDir = vec3( 0., 0., -1. ); 
  vec3 N = faceforward( n, lightDir, n );
  float d = dot( N, -lightDir );
  float s = pow( max( 0.0, dot( vec3( 0., 0., 1. ) , reflect( lightDir, N ) ) ), sh );
  float a = color.a * ( 1. - dot( vec3( 0., 0., 1 ), n ) );
  return vec4(  ks * s * refcolor + kd * d * color.rgb + ka * color.rgb, a );
}
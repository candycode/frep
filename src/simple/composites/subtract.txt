
uniform mat4 $1_Mi;
uniform mat4 $2_Mi;

float $1_F( vec3 );
float $2_F( vec3 );
vec3 $1_G( vec3 );
vec3 $2_G( vec3 );

const float bias = 0.0001;

float blend( float f1, float f2 )
{
  // sphere-sphere
  const float a0 =0.04;
  const float b0 =.4;
  const float b1 =.4;
  // box-sphere
  //const float a0 =0.08;
  //const float b0 =.01;//4;
  //const float b1 =.5;
  return a0 / ( 1. + (f1*f1/b0) + (f2*f2/b1));
}

float composite_F( vec3 v )
{
  vec4 p = vec4( v, 1.0 );
  //return max( $1_F( $1_Mi * p ), -$2_F( $2_Mi * p ) ) + bias; 
  float f1 = $1_F( $1_Mi * p );
  float f2 = $2_F( $2_Mi * p );
  //-f1 -f2 + sqrt( f1 * f1 + f2 * f2 )
  const float bias = 0.002;
  return  -f1 +f2 - sqrt( f1 * f1 + bias + f2 * f2 );//+ blend( f2, f2 );
}

uniform float deltaStep;
vec3 composite_G( in vec3 p )
{
    float tstep = deltaStep;
    float dfdz = composite_F( p + vec3( 0., 0., tstep ) ) - composite_F( p + vec3( 0., 0., -tstep ) );
    float dfdy = composite_F( p + vec3( 0., tstep, 0. ) ) - composite_F( p + vec3( 0., -tstep, 0. ) );
    float dfdx = composite_F( p + vec3( tstep, 0., 0. ) ) - composite_F( p + vec3( -tstep, 0., 0. ) );
    return 0.5 * vec3( dfdx, dfdy, dfdz ) / tstep; 
}

/*vec3 composite_G( vec3 v )
{
  vec4 p = vec4( v, 1.0 );
  float f1 = $1_F( $1_Mi * p );
  float f2 = -$2_F( $2_Mi * p );
  if( f1 < f2 + bias ) return $1_G( $1_Mi * p );
  else return -$2_G( $2_Mi * p );
}*/
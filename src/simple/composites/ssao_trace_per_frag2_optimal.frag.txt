#extension GL_ARB_texture_rectangle : enable
//uniform sampler2DRect depthMap;
//uniform vec4 ssaoviewport;
//uniform int ssao;
#if 1
//#define TEXTURE_ENABLED

// IN: color, normal, position, radius, ssao, depthMap, ssaoviewport width, ssaoviewport height.
// OUT: occlusion modified gl_Color
//#define MRT_ENABLED
#ifdef MRT_ENABLED
uniform sampler2DRect positions;
uniform sampler2DRect normals;
#else
uniform sampler2DRect depthMap;
#endif
/*uniform*/ float numSamples = 32.; //number of rays
/*uniform*/ float hwMax = 128.; //max pixels
uniform int ssao; //enable/disable ssao
/*uniform*/ float dstep = 1.; //step multiplier 
/*uniform*/ float occlusionFactor = 2.; // occlusion multiplier

#ifdef TEXTURE_ENABLED
uniform sampler2D tex;
uniform int textureUnit; // textureUnit < 0 => no texture
uniform int textureEnabled;
#endif

#ifdef MRT_ENABLED // in case of multiple render targets normals are available in 'normals' texture
                   // and world space positions in 'positions' texture
vec3 normal;
vec3 worldPosition;
#else
vec3 normal;
/*varying*/ vec3 worldPosition; 
#endif

/*varying*/ float R = 1.; // radius in world coordinates
/*varying*/ float pixelRadius = 16.; //radius in screen coordinates (=pixels)

uniform vec4 ssaoviewport;

float width = ssaoviewport.z;
float height = ssaoviewport.w;



vec3 screenPosition;

//-----------------------------------------------------------------------------
#ifndef MRT_ENABLED
vec3 ssUnproject( vec3 v )
{
  vec4 p = vec4( v, 1.0 );
  p.x /= width;
  p.y /= height;
  p.xyz -= 0.5;
  p.xyz *= 2.0;
  p = gl_ProjectionMatrixInverse * p;
  p.xyz /= p.w;
  return p.xyz;
}
#endif

//------------------------------------------------------------------------------
//cosine of mininum angle used for angle occlusion computation (~30 deg. best)
/*uniform*/ float minCosAngle = 0.2; // ~78 deg. from normal, ~22 deg from tangent plane
// adjusted pixel radius
float PR = 1.0;
// adjusted world space radius
float PRP = 1.0;
// attenuation coefficient
float BB = 0.0;

// TODO: move in vertex shader; it will be faster only for small models (<1M vertices)
void ComputeRadiusAndOcclusionAttenuationCoeff()
{
  
  // clamp pixel radius to [1.0, max radius]  
  PR = clamp( pixelRadius, 1.0, hwMax );
  // set coefficient for occlusion attenuation function 1 / ( 1 + B * dist^2 )
  // Rw : Rs = NRw : NRs => NRw = Rw * NRs / Rs 
  PRP = R * PR / pixelRadius; // clamp world space radius
  // the coefficient is set such that the occlusion at maximum distance
  // is ~ 1/2 of the peak value
  BB = ( 1.0 - 0.1 ) / ( PRP * PRP );
}

//------------------------------------------------------------------------------
// occlusion function for horizontal (y=y0) lines
float hocclusion( float ds )
{

#if 1
 
  // follow line y = y0 in screen space along negative or positive direction according to ds
  // where:
  //    x0 = screenPosition.x
  //    y0 = screenPosition.y  
  // each point visible from current fragment (i.e. with z < current z)
  // will contribute to the occlusion factor
  int occSteps = 0;  // number of occlusion rays 
  vec3 p = gl_FragCoord.xyz;
  float occl = 0.0; // occlusion
  float z = 1.0; // z in depth map
  float dz = 0.; //
  float dist = 1.; // distance between current point and shaded point 
  float prev = 0.; // previous angular coefficient 
  vec3 I; // vector from point in depth map to shaded point
  int upperI = int( PR / abs( ds ) );
  for( int i = 0; i != upperI; ++i )
  {
      p.x += ds;
#ifdef MRT_ENABLED
    z = texture2DRect( normals, p.xy ).w;
#else
    z = texture2DRect( depthMap, p.xy ).x;
#endif   
    // compute angular coefficient: if angular coefficient
    // is greater than last computed coefficient it means the point is 
    // visible from screenPosition and therefore occludes it 
    dz = screenPosition.z - z;
    dist = distance( p.xy, screenPosition.xy );
    float angCoeff = dz / dist;
    if( angCoeff > prev )      
    {
      p.z = z;
      prev = angCoeff;
      // compute vector from point in world coordinates to point whose
      // occlusion is being computed
#ifdef MRT_ENABLED // when Multiple Render Targets is enabled the world position
                   // of each pixel is available in 'positions' texture
      I = texture2DRect( positions, p.xy ).xyz - worldPosition.xyz;
#else
      I = ssUnproject( p ) - worldPosition.xyz;
#endif
      // ADD AO contribution: function of angle between normal and ray
      float k = dot( normal, normalize( I ) );
      // if occluded compute occlusion and increment number of occlusion
      // contributions
      if( k > minCosAngle )
      {
        occl += ( k / ( 1. + BB * dot( I, I ) ) );
        ++occSteps;
      }
    }      
  }
  // return average occlusion along ray: divide by number of occlusions found 
  return occl / max( 1.0, float( occSteps ) );
#endif //0  
}

//------------------------------------------------------------------------------
// occlusion function for vertical (x=x0) lines
float vocclusion( float ds )
{
  
#if 1  
 
  // follow line x = x0 in screen scpace along negative or positive direction according to ds
  // where:
  //    x0 = screenPosition.x
  //    y0 = screenPosition.y  
  // each point visible from current fragment (i.e. with z < current z)
  // will contribute to the occlusion factor
  int occSteps = 0;  // number of occlusion rays 
  vec3 p = gl_FragCoord.xyz;
  float occl = 0.0; // occlusion
  float z = 1.0; // z in depth map
  float dz = 0.; //
  float dist = 1.; // distance between current point and shaded point 
  float prev = 0.; // previous angular coefficient 
  vec3 I; // vector from point in depth map to shaded point
  int upperI = int( PR / abs( ds ) );
  for( int i = 0; i != upperI; ++i )
  {
    p.y += ds; 
#ifdef MRT_ENABLED
    z = texture2DRect( normals, p.xy ).w;
#else
    z = texture2DRect( depthMap, p.xy ).x;
#endif    
    // compute angular coefficient: if angular coefficient
    // is greater than last computed coefficient it means the point is 
    // visible from screenPosition and therefore occludes it 
    dz = screenPosition.z - z;
    dist = distance( p.xy, screenPosition.xy );
    float angCoeff = dz / dist;
    if( angCoeff > prev )      
    {
      p.z = z;
      prev = angCoeff;
      // compute vector from point in world coordinates to point whose
      // occlusion is being computed
#ifdef MRT_ENABLED // when Multiple Render Targets is enabled the world position
                   // of each pixel is available in 'positions' texture
      I = texture2DRect( positions, p.xy ).xyz - worldPosition.xyz;
#else
      I = ssUnproject( p ) - worldPosition.xyz;
#endif
      // ADD AO contribution: function of angle between normal and ray
      float k = dot( normal, normalize( I ) );
      // if occluded compute occlusion and increment number of occlusion
      // contributions
      if( k > minCosAngle )
      {
        occl += ( k / ( 1. + BB * dot( I, I ) ) );
        ++occSteps;
      }
    }      
  }
  // return average occlusion along ray: divide by number of occlusions found 
  return occl / max( 1.0, float( occSteps ) );
#endif //0  
}

//------------------------------------------------------------------------------
// occlusion function for non degenerate (i.e. lines not parallel to x or y axis) lines
float occlusion( vec2 dir )
{
 
#if 1
  // compute angular coefficient and steps
  float m = dir.y / dir.x;
  
  // follow line y = m * ( x - x0 ) + y0 in screen space
  // where:
  //    m = dir.y / dir.x
  //    x0 = screenPosition.x
  //    y0 = screenPosition.y  
  // each point visible from current fragment (i.e. with z < current z)
  // will contribute to the occlusion factor
  int occSteps = 0;  // number of occlusion rays 
  vec3 p = gl_FragCoord.xyz;
  // compute number of i (x) steps
  // size of radius = sqrt( (num x steps)^2 + (ang. coeff. * num x steps)^2 )
  int upperI = int( PR * inversesqrt( 1.0 + m * m ) / abs( dstep ) );
  float occl = 0.0; // occlusion
  float z = 1.0; // z in depth map
  float dz = 0.; //
  float dist = 1.; // distance between current point and shaded point 
  float prev = 0.; // previous angular coefficient 
  vec3 I; // vector from point in depth map to shaded point
  float ds = sign( dir.x ) * dstep;
  for( int i = 0; i != upperI; ++i )
  {
    p.x += ds;
    p.y += ds * m;
#ifdef MRT_ENABLED
    z = texture2DRect( normals, p.xy ).w;
#else
    z = texture2DRect( depthMap, p.xy ).x;
#endif   
    // compute angular coefficient: if angular coefficient
    // is greater than last computed coefficient it means the point is 
    // visible from screenPosition and therefore occludes it 
    dz = screenPosition.z - z;
    dist = distance( p.xy, screenPosition.xy );
    float angCoeff = dz / dist;
    if( angCoeff > prev )      
    {
      p.z = z;
      prev = angCoeff;
      // compute vector from point in world coordinates to point whose
      // occlusion is being computed
#ifdef MRT_ENABLED // when Multiple Render Targets is enabled the world position
                   // of each pixel is available in 'positions' texture
      I = texture2DRect( positions, p.xy ).xyz - worldPosition.xyz;
#else
      I = ssUnproject( p ) - worldPosition.xyz;
#endif
      // ADD AO contribution: function of angle between normal and ray
      float k = dot( normal, normalize( I ) );
      // if occluded compute occlusion and increment number of occlusion
      // contributions
      if( k > minCosAngle )
      {
        occl += ( k / ( 1. + BB * dot( I, I ) ) );
        ++occSteps;
      }
    }      
  }

  // return average occlusion along ray: divide by number of occlusions found 
  return occl / max( 1.0, float( occSteps ) );
#endif //0  
}

//------------------------------------------------------------------------------
float ComputeOcclusion()
{
 
#if 1 
    // numSamples is an upper limit fr the number of directions == number of rays
    // if the 2D (i,j) sample points are laid out on the edges of a square
    // and numSamples is the total number of points then the number of samples on one edge
    // is numSamples / 4;
    // the i and j indices are assumed to be in the range:
    //  [-(numSamples / 4) / 2, +(numSamples / 4) / 2] == [ -numSamples/8,+numSamples/8 ]
    int hw = int( max( 1.0, numSamples / 8.0 ) ); 	
    // ppos is [x pixel, y pixel, depth (0..1) ]
    float occ = 0.0;
    int i = -hw;
    int j = -hw;
    // vertical edges, j = 0 excluded
    for( ; j != 0; ++j ) occ += occlusion( vec2( float( i ), float( j ) ) );
    for( j = 1; j != hw + 1; ++j ) occ += occlusion( vec2( float( i ), float( j ) ) );
    i = hw;
    for( ; j != hw + 1; ++j ) occ += occlusion( vec2( float( i ), float( j ) ) );
    for( j = 1; j != hw + 1; ++j ) occ += occlusion( vec2( float( i ), float( j ) ) );
    // horizontal edges, i = 0 excluded
    j = -hw;
    for( i = -hw + 1; i != 0; ++i ) occ += occlusion( vec2( float( i ), float( j ) ) );
    for( i = 1; i != hw; ++i ) occ += occlusion( vec2( float( i ), float( j ) ) );
    j = hw;
    for( i = -hw + 1; i != 0; ++i ) occ += occlusion( vec2( float( i ), float( j ) ) );
    for( i = 1; i != hw; ++i ) occ += occlusion( vec2( float( i ), float( j ) ) ); 
    // i = 0 and j = 0
    occ += hocclusion( -dstep );
    occ += hocclusion( dstep );
    occ += vocclusion( -dstep );
    occ += vocclusion( dstep );
    // divide occlusion by the number of shot rays
    occ /= max( 1.0, float( 8 * hw - 2 ) );
    return occ;
#endif    
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
vec4 ComputeColor( vec3 P, vec3 N )
{

  
  if( !ssao ) return vec4( 1., 0., 0., 1. );
  
    vec4 color;
    // INVERTED NORMAL USEFUL FOR DISPLACEMENT MAPPING
    normal = -N;
    worldPosition = ssUnproject(vec3( gl_FragCoord.xy, texture2DRect( depthMap, gl_FragCoord.xy ).x ) );
    ComputeRadiusAndOcclusionAttenuationCoeff();
#ifdef MRT_ENABLED
    normal = texture2DRect( normals, gl_FragCoord.xy ).xyz;
    worldPosition = texture2DRect( positions, gl_FragCoord.xy ).xyz;
#endif


// screen space occlusion is computed by accumulating the occlusion obtained
// by intersecting a number of rays with the surrounding geometry;
// the ray starting point is the current fragment and the directions are computed by
// iterating over coordinates along the edges of a square matrix

    // (-i_max,j_max)   (-i_max+1,j_max) ...  (i_max,j_max)
    // (-i_max,j_max-1)         .             (i_max,j_max-1) 
    //       .                  .                   .  
    //       .                  .                   .
    //       .                  .                   .
    // (-i_max,-j_max)  (-i_max+1,-j_max) ... (i_max,-j_max)

    // (i,j) indices are then transformed into angular coefficients assigned to rays 
#if defined( AO_LAMBERT )  // lambert shading
  color.rgb = gl_FrontMaterial.diffuse.rgb * dot( normal, -normalize( worldPosition ) );
  color.a = gl_FrontMaterial.diffuse.a;
#elif defined( AO_FLAT ) // color only
  color = gl_FrontMaterial.diffuse;
#elif defined( AO_SPHERICAL_HARMONICS )
  color.rgb = SphHarmShade();
  color.a =  gl_FrontMaterial.diffuse.a;
#else // ambient occlusion only
  color = vec4(1.0);
#endif
  if( ssao > 0 )
  {
    // set screen position for further usage in ambient occlusion computation
    // in this case the fragment coordinate z coord has not yet been modified
    // so we need to use the value in the depth map
    screenPosition = vec3( gl_FragCoord.xy, texture2DRect( depthMap, gl_FragCoord.xy ).x ) ;
    // multiply the color intensity by 1 - occlusion
    color.rgb *= 1.0 - smoothstep( 0.0, 1.0, ComputeOcclusion() * occlusionFactor );   
  }

#ifdef TEXTURE_ENABLED
  if( textureUnit >= 0 && bool( textureEnabled ) ) color *= texture2D( tex, gl_TexCoord[ textureUnit ].st );
#endif
  
#if defined( AO_SPHERICAL_HARMONICS )
  color += 0.1 * gl_FrontMaterial.ambient;    
#endif
  return color;

}
  


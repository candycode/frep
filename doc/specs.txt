------
FrepUp
------

GUI program for creating 3D models by mixing functional representations.
The textual representation used to describe the objects, blending functions
and materials is the GLSL language version 1.30 or later.

*Object creation

It shall be possible to create a 3D object by:

- specify its functional representation through

  + a function in the form <objectname>_F(x,y,z) = 0

  + a gradient function in the form <objectname>_G(x,y,z), the gradient
    function shall be considered optional: in case the gradient funtion is
    not specified the normal shall be computed through a finite difference method
    and/or a two pass technique (1st pass render to depth map/positions, 2nd pass shade)

- specify a composition of previously defined functions; the supported CSG operations shall be:
  
  + union with blending
  
  + intersection with blending

  + subtraction with blending

- it shall be possible to specify

In case objects are specified as compositions the full construction tree must be visible at
any given time and in case the 3D objects are moved or rotated (i.e. if their modelview matrix changes)
such changes must be reflected in the composed object in real-time.

The object material can be defined for individual object and as a composition of the materials
composing the composite object (feature deferred).

At any given time it shall be possible to "collapse" the 3D composite object into an elementary 3D
object so that such object is reusable as a basic building block for new composite objects (feature deferred).

*GUI

The GUI shall consist of:

- a main window containing all the widgets

- a 3D window displaying the individual objects

- a 3D window displaying the composite object

- a list view listing the available objects

- a tree view showing the CSG/composition tree for the composite object

- a tool bar with buttons for:

  + adding a new object
 
  + editing an object 
  
  + removing an object

  + adding an operation node to the construction tree

  + adding a base object to the composition tree
 
  + buttons for load and save models/scenes to file 

- a menu with the same entries as the toolbar plus an about/help item.

- a text edit box used to modify the GLSL code


*Operations

Basic operations:
 Union f1,f2: max(f1,f2)
 Intersection f1,f2: min(f1,f2)
 Subtraction f1,f2: min(f1,-f2)

Each operation can be extended with blending (use blending operations defined in Free Dimensions).

*Rendering algorithm

For primitive objects (i.e. no CSG tree) Use ray-tracing with boxes as proxy geometries.

For composite objects (i.e. with CSG tree) use ray-tracing with:

 1) a box that contains all the axis-aligned boxes of the primitive objects OR
 
 2) a composite object witch is the union of all the individual boxes: hard because
    each box can also be rotated the only way I know of building such an object
    is to create a BSP tree containing the geometries of the boxes and then apply a CSG
    union operation to extract the triangles that compose the optimal proxy object

 3) create a proxy object that is generated with a coarse triangulation of the actual
    composite F-Rep this is easier than (2) and the acrual evaluation of the scalar field
    can still be perfomed on the GPU; the 3D grid can then be generated slice-by-slice and
    the final polygonalization can be peformed with the regulat marching cube method

 4) use geometry shaders to generate the coarse-grained proxy geometry: same as (3) but
    the proxy geometry is generated by the geometry shader

Note that the proxy geometry has to be recomputed each time a primitive object is added,
removed, translated, scaled and rotated.

The fragment shader that performs the ray-primitive instersection shall have access
to the inverse transformation matrix of each primitive object so that composite operations such as

 min( obj1_F( obj1_M^(-1) * [x,y,z] ), obj2_F( obj2_M^(-1) * [x,y,z] ) )

where <object name>_F is the functional representation of object <object name> and <object name>_M
is the affine transformation applied to the object through manipulators

can be perfomred

Inverse of primitive objects transformations shall be passed as uniform variables to the composite
shader

The composite shader itself is compiled into a textual GLSL representation from the CSG tree.

*Tools

3D Library: OpenSceneGraph; somehow buggy (e.g. see manipulators) but only solution available
            to guarantee a good level of performance and productivity, also examples of how
            to embed it into Firefox are available, web interface can then be generated with
            plugin+javascript (btw if multiple rendering steps are required Java3D cannot be used).
            Supports the STL and PLY (with my own and other plugin) file formats.

GUI Library: Trolltech Qt; main reasons are:

             + ease of programming
             + embedded javascript scripting engine
             + easy to interface with Python 
             + most important: easy to perform automatic GUI testing/macro recording by
               installing an event filter (doesn't solve all the problems on the Mac where code
               injection is more appropriate, several examples available)
             + easy to package and ditribute applications on multiple platforms (tried on every platform
               except for Snow Leopard)
             + easy to build scriptable multi-browser plugins through the QtBrowserPlugin solution; this is
               also the best solution for testing because plugins can be tested (including javascript scripting)
               as a stand-alone application and run into a web browser after the testing phase

             Other toolkit examined: WxWindows, FLTK, Fox, Mozilla XUL/XPCOM 

Boost ?: not really needed at this stage, the bcp tool allows to extract a subset but again not needed,
         OpenSceneGraph and Qt have facilities that cover pretty much all is needed inlcuding smart pointers
         and thread management

Project management: RedMine (already installed) on Mongrel, supports everything including discussion groups,
                    Trac could be considered

Configuration management: Subversion (already installed but git and Bazaar are good as well and better
                          in many regards)

Build tool: CMake (optionally with CTest and CPack + testing dashboard)

Distribution: nullsoft for Windows, deb package for Linux, dmg file on Mac
              (see molekel packaging scripts for samples)

Target compilers: Mac gcc 4.0 (Tiger), Linux gcc 4.3, Windows VC++ 2008 (will compile on MinGW with gcc 4.3+).  
                   

*Architecture

Use MVP-derived architecture with GUI widgets abstracted as presenters,
interactors, commands, controller and model; no need for selectors at this time. 

*Volume Rendering

The same application could be extended to visualize volume redered data which could
then be easily exported to 



     






 

  
 